##Load packages
```{r Load packages}
library(lubridate)
```
##Download data and documentation, create log file and load the data in R
```{r Download data and documentation, cache=TRUE}
link_data <- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2"
link_doc1 <- "https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2Fpd01016005curr.pdf"
link_doc2 <- "https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2FNCDC%20Storm%20Events-FAQ%20Page.pdf"
date <- date()
##create directory for raw data
if(!file.exists("./raw_data")) {
      dir.create("./raw_data")
      }
##download data and create log file of the download
if(!file.exists("./raw_data/StormData.csv.bz2")) {
      link <- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2"
      date <- date()
      log <- paste("Data downloaded from:", link, "on", date, sep = " ")
      write.table(log, "./raw_data/data_access_log.txt")
      download.file(link_data, 
                    "./raw_data/StormData.csv.bz2", 
                    method = "curl")
      rm(date, link, log)
      }
##download documentation
if(!file.exists("./raw_data/StormDataDoc.pdf")) {
      download.file(link_doc1, 
                    "./raw_data/StormDataDoc.pdf", 
                    method = "curl")
      }
if(!file.exists("./raw_data/StormDataFAQ.pdf")) {
      download.file(link_doc2, 
                    "./raw_data/StormDataFAQ.pdf", 
                    method = "curl")
      }
```

##read the data
```{r Read the data, cache=TRUE}
if(!exists("StormData")) {
      StormData <- read.csv(bzfile("./raw_data/StormData.csv.bz2"), stringsAsFactors = FALSE, header = TRUE)
      }

rm(link, link_doc1, link_doc2, link_data)
```


##Pre-processing
Check the headings of the original dataset
```{r Headings of the dataset}
names(StormData)
```
Select relevant columns
```{r Select relevant columns, cache=TRUE}
df <- with(StormData, 
           data.frame(state = STATE,
                      bgn_date = as.Date(as.character(StormData$BGN_DATE), format = "%m/%d/%Y"),
                      evtype = as.factor(EVTYPE), 
                      fatalities = FATALITIES, 
                      injuries = INJURIES, 
                      propdmg = PROPDMG, 
                      propdmgexp = PROPDMGEXP, 
                      cropdmg = CROPDMG, 
                      cropdmgexp = CROPDMGEXP,
                      remarks = REMARKS)
           )
```

##analysis of the dataset

EVTYPE.txt is a list of the EVTTYPE taken from the documentation downloaded as StormDataDoc.pdf (p.6, table 1. Storm Data Event Table)
```{r Analysis of the dataset, cache=TRUE}
evtype_doc <- scan("./raw_data/EVTYPE.txt", what = "", sep = "\n")#read the list
evtype_doc <- substr(evtype_doc, 1, nchar(evtype_doc) - 2)#remove the character "designator"
evtype_data <- as.character(levels(df$evtype))
```
The difference between EVTYPE's categories of the documentation and the data
```{r}
cbind(EVTYPE.DOCUMENTATION = length(evtype_doc), EVTYPE.DATA = length(levels(df$evtype)))
print(evtype_doc)
print(evtype_data)
#cleaning EVTYPE

```

The following code uses the function clean_evtype to create a dataframe. The function takes an external list saved as csv, as input. The list has two columns :the first one contains text strings to be used as grep in the evtype column of the data, the second indicates the correspondant category of the 48 defined in the documentation. 
To compile this list, I first simply used the 48 categories as grep and then I refined it in further iteration of the function clean_evtype(). It contains some redundant lines as it was compiled by further refinement, without changing the existing. 
The list was compiled using a spreadsheet editor and saved in csv and it is  included in the repository with the present code.

```{r}
#conditions
clean_evtype <- function(subject = "evtype_data", condition_list = "conditions.csv") {
      cond <- read.csv(condition_list, stringsAsFactors = FALSE, header = TRUE, sep = ";")
      evtype_clean <- data.frame(evtype = evtype_data, output = NA, stringsAsFactors = FALSE)
      for(i in 1:length(cond$grep)) {
            index <- grep(cond$grep[i], evtype_clean$evtype, ignore.case = TRUE)
            if(length(index > 0)) {
                  for(z in 1:length(index)) {
                        evtype_clean$output[index[z]] <- cond$output[i]     
                  }
                  
            }
      }
      for(i in 1:length(evtype_clean$output)) {
            evtype_clean$output[is.na(evtype_clean$output)] <- "Other"
      }
      evtype_clean$evtype <- as.factor(evtype_clean$evtype)
      evtype_clean$output <- as.factor(evtype_clean$output)
      evtype_clean <<- evtype_clean
      write.table(evtype_clean, "evtype_clean.csv")
}

```
The following list is then used to reassign the categories to the working dataframe df
```{r}
print(evtype_clean)
for(i in 1:length(df$evtype)) {
      index <- grep(make.names(evtype_clean$evtype[i]), make.names(df$evtype[i]))
      if(length(index > 0 )) {
            for(z in 1:length(index)) {
                  df$evtype[index[z]] <- evtype_clean$output[i]
            }
      }
}
```

```{r}
df$evtype[i] <- evtype_clean$output[which(df$evtype[i] == evtype_clean$evtype)]
```





